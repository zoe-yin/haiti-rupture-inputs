!EvalModel
parameters: [alpha, Omega, Omegaf,b_xx, b_yy, b_zz, b_xy, b_xz, b_yz, c_xx, c_yy, c_zz, c_xy, c_xz, c_yz, eCS]
model: !Switch
  [c_xx, c_yy, c_zz, c_xy, c_xz, c_yz]: !Include FL33_stress_change_kinematic_model.yaml
  # Cij is the heterogeneous stress model from FL33
  [alpha]: !ConstantMap #alpha = -1 switches the sign from the FL33 output
    map:
      alpha: -1
  [Omegaf]: !LayeredModel
    map: !AffineMap
      matrix:
        z0: [0.0, 0.0, 1.0]
      translation:
        z0: 0
    interpolation: linear
    parameters: [Omegaf]
    nodes:
      10e3: [0.0]
      -6e3: [0.0]
      -8e3: [0.05]
      -10e3: [1.0]
      -20e4: [1.0]
  [Omega]: !FunctionMap
    #Tappering of the deviatoric stress with shallow and deeper depth for the seismogenic width
    map:
      Omega: |
       if (z > -9000.0){
         return z/-9000.0;
       } else {
         if (z > -45000.0){
           return 1.0;
         }
         if (z < -55000.0){
           return 0.0;
         }
         return (-55000.0-z)/(-55000.0+45000.0);
       }
  [b_xx, b_yy, b_zz, b_xy, b_xz, b_yz]: !EvalModel  # Regional stress model 
    parameters: [effectiveConfiningStress]
    model: !FunctionMap
      map:
        #Same as eCS
        # below defines 1d layer effective normal stress for each layer (based on material properties)
        # Here Jeremy has 4 layers 
        # Here you have OP as the overpressure ratio (which defines the pore fluid pressure)
        # Some define a linearly increasing or constant effective normal stress to 20-30 MPa below some depther, (check for Turkey)
        effectiveConfiningStress: |
          OP = 0.1;
          if (z >= -3000) {
            Rh = 2300;
            return OP*Rh*9.8*(-3000);
          }
          if (z >= -18000) {
            Rh = 2400;
            return OP*9.8*(Rh*(z+3000) + 2300*(-3000));
          }
          if (z >= -33000) {
            Rh = 2800;
             return OP*9.8*(Rh*(z+18000) + 2400*(-15000) + 2700*(-3000));
          }
          if (z < -33000) {
            Rh = 3200;
             return OP*9.8*(Rh*(z+33000) + 2800*(-15000) + 2400*(-15000) + 2700*(-3000));
          }
    components: !AndersonianStress
    # See notes on Andersonian Stress map: https://easyinit.readthedocs.io/en/latest/maps.html#optimalstress
      constants:
        mu_d:      <double>
        mu_s:      <double>
        SH_max:    55
        S_v:       <int (1,2 or 3)>
        cohesion:  <double>
        s2ratio:   <double>
        S:         <double>
        sig_zz:    <double>
  [eCS]: !FunctionMap
    map:
      #avoid positive stress above z=0
      eCS: |
          OP = 0.1;
          if (z >= -3000) {
            Rh = 2300;
            return OP*Rh*9.8*(-3000);
          }
          if (z >= -18000) {
            Rh = 2400;
            return OP*9.8*(Rh*(z+3000) + 2300*(-3000));
          }
          if (z >= -33000) {
            Rh = 2800;
             return OP*9.8*(Rh*(z+18000) + 2400*(-15000) + 2700*(-3000));
          }
          if (z < -33000) {
            Rh = 3200;
             return OP*9.8*(Rh*(z+33000) + 2800*(-15000) + 2400*(-15000) + 2700*(-3000));
          }
# considering regional stress
# Bij - reigonal stress model, Cij - stress tensor from FL33
# Omegaf - tapering filter for the Cij 
# Alpha - to flip the sign of the Cij - stress ouptut
# Omega - seismogenic width filter 
# and since the stress tensor is tapered by Omega, we have to add the confining stress "eCS"
components: !LuaMap
  returns: [s_xx, s_yy, s_zz, s_xy, s_xz, s_yz]
  function: |
    function f (x)
      return {
        s_xx = x["Omega"] * (x["b_xx"] + x["Omegaf"] * x["c_xx"] * x["alpha"]) + (1.0-x["Omega"]) * x["eCS"],
        s_yy = x["Omega"] * (x["b_yy"] + x["Omegaf"] * x["c_yy"] * x["alpha"]) + (1.0-x["Omega"]) * x["eCS"],
        s_zz = x["Omega"] * (x["b_zz"] + x["Omegaf"] * x["c_zz"] * x["alpha"]) + (1.0-x["Omega"]) * x["eCS"],
        s_xy = x["Omega"] * (x["b_xy"] + x["Omegaf"] * x["c_xy"] * x["alpha"]),
        s_xz = x["Omega"] * (x["b_xz"] + x["Omegaf"] * x["c_xz"] * x["alpha"]),
        s_yz = x["Omega"] * (x["b_yz"] + x["Omegaf"] * x["c_yz"] * x["alpha"])
      }
      end

#      end
#components: !FunctionMap
#  map:
#    s_xx: return Omegaf*alpha*c_xx + eCS;
#    s_yy: return Omegaf*alpha*c_yy + eCS;
#    s_zz: return Omegaf*alpha*c_zz + eCS;
#    s_xy: return Omegaf*alpha*c_xy;
#    s_xz: return Omegaf*alpha*c_xz;
#    s_yz: return Omegaf*alpha*c_yz;